{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Establish baseline Godot 4.5.1 C# Windows project",
        "description": "Create the canonical baseline Godot 4.5.1 C# Windows project used by all later setup tasks.",
        "details": "Create the single canonical Godot 4.5.1 .NET project on Windows, verify C# compile/run, define core folder layout, and produce a runnable Windows export baseline. This task owns initial project creation and must not be duplicated by downstream setup tasks.",
        "testStrategy": "Verify editor open, C# build, main scene run, and Windows export run from the same canonical project root. Fail if any downstream setup task creates a second independent project root.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Lock canonical project-root contract",
            "description": "Define single-root constraints, required folders, and startup-scene ownership for the baseline Windows C# project.",
            "status": "pending",
            "priority": "high",
            "dependencies": [],
            "details": "Document canonical root, mandatory structure, and startup binding constraints used by all downstream tasks.",
            "testStrategy": "Contract checks reject secondary project roots and missing baseline folders.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement baseline bootstrap and verification flow",
            "description": "Create/open baseline project, validate C# compile, and verify editor startup flow and export preset availability.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "1"
            ],
            "details": "Wire deterministic bootstrap flow for editor run and Windows export baseline verification.",
            "testStrategy": "Integration smoke verifies editor startup and export preset readiness.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Publish baseline evidence and hard-gate tests",
            "description": "Emit baseline verification evidence and gate failures for missing compile/startup/export conditions.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "2"
            ],
            "details": "Produce deterministic evidence artifacts and fail fast when baseline checks are incomplete.",
            "testStrategy": "Task-level gate tests validate baseline evidence completeness and fail conditions.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 2,
        "title": "Implement config-first balancing system",
        "description": "Create a configuration system to manage game balance values (e.g., wave budgets, day durations) without hardcoding.",
        "details": "Define a JSON or INI configuration file structure. Create a ConfigManager C# class to load and parse config files. Include settings for day/night durations (4 min Day, 2 min Night), normal wave budget (day1=50, daily growth=120%), elite/boss channels, spawn cadence (10s), boss count (2). Ensure config values are accessible globally in the game. Use Godot's Resource system or custom file I/O.",
        "testStrategy": "Load config file and verify values are correctly parsed. Test dynamic updates by modifying config and checking in-game effects. Ensure no hardcoded balance values exist in code.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define balancing config contract and file layout",
            "description": "Specify config structure and required fields for day/night timing, wave budgets, channels, cadence, and boss rules.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "1"
            ],
            "details": "Create canonical config sections and key names; map each key to runtime owner and default value policy.",
            "testStrategy": "Contract checks verify all mandatory keys exist and names remain stable across revisions.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "2",
            "title": "Implement ConfigManager loading and typed parsing",
            "description": "Build a C# ConfigManager that loads config files and parses them into typed runtime models.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "2.1",
              "1"
            ],
            "details": "Add load order, typed DTO mapping, and deterministic defaults for absent optional fields.",
            "testStrategy": "Parsing tests assert typed values for valid config and deterministic failure for malformed input.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "3",
            "title": "Expose runtime accessors for balancing values",
            "description": "Provide stable access APIs for day/night durations, wave budgets, channel budgets, spawn cadence, and boss count.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "2.2"
            ],
            "details": "Bind accessors used by loop, wave, and spawn systems without duplicating constants elsewhere.",
            "testStrategy": "Integration checks prove consuming systems read values only from ConfigManager accessors.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "4",
            "title": "Add invalid-config fallback and audit traces",
            "description": "Implement deterministic fallback behavior for invalid config and emit audit evidence for failure paths.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2.2"
            ],
            "details": "Define reject/fallback rules and write validation outcomes with actionable reason codes.",
            "testStrategy": "Negative tests cover missing keys, wrong types, and out-of-range values with expected fallback behavior.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "5",
            "title": "Harden with anti-hardcode and regression tests",
            "description": "Add tests that enforce config-first ownership and prevent reintroduction of hardcoded balance constants.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2.3",
              "2.4"
            ],
            "details": "Include source scans and behavior tests that fail when runtime diverges from config-driven values.",
            "testStrategy": "Gate passes only when config mutation changes runtime behavior without code edits.",
            "subtasks": [],
            "parentId": "undefined"
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 3,
        "title": "Develop runtime state machine for Day/Night cycles",
        "description": "Implement a state machine to manage Day and Night cycles with deterministic progression up to Day15.",
        "details": "Create a GameStateManager C# class with states: Day, Night. Use timers based on config (Day=4 min, Night=2 min). Track current day (1-15). Implement deterministic behavior using a fixed seed for random events. Transition between states automatically. On Day15 completion, trigger win condition. Integrate with Godot's process loop for updates.",
        "testStrategy": "Run game and verify Day/Night cycles switch correctly per config times. Test deterministic progression with fixed seed. Ensure win triggers after Day15.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define runtime state machine model and transitions",
            "description": "Design explicit Day and Night states, transition guards, and deterministic state events.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "2"
            ],
            "details": "Document state graph, transition conditions, and emitted events consumed by downstream systems.",
            "testStrategy": "State graph tests verify legal transitions and reject invalid transition attempts.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "2",
            "title": "Implement timer-driven Day/Night progression",
            "description": "Implement 4-minute Day and 2-minute Night timers with deterministic day counter advancement.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "3.1",
              "2"
            ],
            "details": "Use config-bound durations and ensure timer updates are monotonic and frame-rate independent.",
            "testStrategy": "Timing tests assert exact transition boundaries under fixed-step and variable-step updates.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "3",
            "title": "Integrate fixed-seed deterministic progression",
            "description": "Bind fixed-seed randomness and transition checkpoints to guarantee repeatable cycle behavior.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "3.2"
            ],
            "details": "Emit deterministic checkpoints at every phase boundary for replay comparison.",
            "testStrategy": "Same-seed replay tests must produce identical phase and checkpoint sequences.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "4",
            "title": "Implement Day15 terminal trigger and state lock",
            "description": "Trigger terminal flow when Day15 cycle completes and lock further progression updates.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "3.3"
            ],
            "details": "Ensure only one terminal state is emitted and post-terminal transitions are ignored.",
            "testStrategy": "Terminal tests verify single terminal emission and no post-terminal progression.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "5",
            "title": "Add deterministic cycle verification tests",
            "description": "Create unit and scene tests covering timing, transitions, and terminal conditions.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "3.4"
            ],
            "details": "Cover normal flow, edge timing boundaries, and forced terminal scenarios with fixed seeds.",
            "testStrategy": "Coverage must include transition correctness and deterministic replay parity checks.",
            "subtasks": [],
            "parentId": "undefined"
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 4,
        "title": "Implement wave budget and channel system",
        "description": "Set up wave generation with normal, elite, and boss channels based on configurable budgets.",
        "details": "Create WaveManager C# class. Calculate normal wave budget: start from config (day1=50) and apply daily growth (120%). Elite and boss channels are independent; define configurable budgets for them. Spawn enemies based on budget allocation. Use deterministic random number generation with fixed seed. Ensure channels can be tuned independently via config.",
        "testStrategy": "Test wave budget calculations for multiple days. Verify elite and boss channels do not affect normal budget. Check config tuning modifies wave generation appropriately.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define wave-budget and channel rules",
            "description": "Specify budget growth formula, channel boundaries, and elite/boss budget isolation constraints.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock per-day budget inputs, channel accounting fields, and elite/boss independent accounting policy.",
            "testStrategy": "Contract tests verify budget math inputs and channel isolation invariants.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement budget engine and channel accounting",
            "description": "Build deterministic budget allocator that computes per-wave/channel spend under locked rules.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic allocation and enforce no cross-channel leakage in runtime accounting.",
            "testStrategy": "Unit tests verify deterministic budget outputs and channel totals.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add regression and audit evidence for budget flow",
            "description": "Add replay-safe checks and logs proving budget progression and channel accounting correctness.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit per-wave budget evidence and reject invalid accounting transitions.",
            "testStrategy": "Regression tests assert repeatable budget traces under fixed seeds.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 5,
        "title": "Create enemy spawning system with cadence",
        "description": "Develop a spawning system that continuously spawns enemies during the first 80% of Night with a 10s cadence.",
        "details": "In WaveManager, implement spawning logic during Night state. Calculate Night duration from config (2 min). Spawn enemies continuously in first 80% of Night (i.e., 96 seconds) with a 10-second cadence. Use timers to trigger spawns. In last 20% of Night (24 seconds), stop new spawns. Handle boss nights with fixed count=2 from config. Spawn enemies at predefined spawn points in the game world.",
        "testStrategy": "Run game during Night and verify spawning occurs in first 80% with 10s intervals. Confirm no spawns in last 20%. Test boss night spawns exactly 2 bosses.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define spawn cadence and composition contract",
            "description": "Specify spawn cadence windows, per-channel pacing, and composition constraints for normal/elite/boss nights.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock cadence fields and deterministic sequencing keys consumed by spawner runtime.",
            "testStrategy": "Contract checks validate cadence and required composition fields.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement deterministic spawner orchestration",
            "description": "Implement spawn scheduler that follows cadence, channel assignments, and seeded ordering.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Use seeded deterministic ordering and enforce per-channel emission boundaries.",
            "testStrategy": "Simulation tests verify stable spawn order with same seed.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add spawn regression and failure-path coverage",
            "description": "Cover invalid cadence inputs, channel overflow, and fallback behaviors with deterministic assertions.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit structured spawn diagnostics and fail on malformed composition states.",
            "testStrategy": "Regression tests assert fallback behavior and deterministic traces.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 6,
        "title": "Implement enemy AI with target priority and pathing",
        "description": "Develop enemy AI that follows target priority rules and handles blocked paths with fallback attacks.",
        "details": "Create EnemyAI C# script attached to enemy nodes. Define target priority when path is valid: unit > castle > armed defense > wall/gate. Use Godot's navigation system for pathfinding. If path is blocked, fallback to attack nearest blocking structure. Use seeded tie-break for determinism in case of multiple targets. Ensure friendly fire is disabled for player attacks (set collision layers/masks accordingly).",
        "testStrategy": "Spawn enemies and verify they target correctly per priority. Test blocked path scenario to ensure fallback attack triggers. Check deterministic behavior with fixed seed. Confirm friendly fire is disabled.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define enemy target-priority and pathing policy",
            "description": "Define target selection order, blocked-path fallback, and tie-break policies for deterministic AI behavior.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock AI priority chain and seeded tie-break rules for repeatable outcomes.",
            "testStrategy": "Contract tests verify target-priority and tie-break rule declarations.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement pathing and target selection runtime",
            "description": "Implement runtime selection logic for nearest valid target and path-cost-based movement under constraints.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic path-cost evaluation and target switching without illegal path traversal.",
            "testStrategy": "Unit tests verify path selection and target switching behaviors.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add blocked-map and recovery regression tests",
            "description": "Validate fully blocked scenarios, fallback activation, and recovery once valid routes reappear.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit pathing diagnostics and ensure no deadlock under blocked-map conditions.",
            "testStrategy": "Integration tests verify blocked-map fallback and deterministic recovery.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 7,
        "title": "Set up castle HP and loss condition",
        "description": "Implement castle health system and loss condition when HP reaches 0.",
        "details": "Create Castle C# script with HP property. Initialize HP from config (value to be defined, but loss at 0). When enemies attack castle, reduce HP. On HP=0, trigger loss condition (game over). Display HP in UI (basic implementation). Integrate with enemy AI targeting.",
        "testStrategy": "Attack castle with enemies and verify HP decreases. Test loss condition triggers at HP=0. Ensure it aligns with game state.",
        "priority": "medium",
        "dependencies": [
          1,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define castle HP terminal-state contract",
            "description": "Define castle HP fields, damage application rules, and lose-condition trigger contract.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock castle HP mutation boundaries and terminal-state transition conditions.",
            "testStrategy": "Contract tests verify terminal trigger and HP bounds.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement castle damage and lose-condition flow",
            "description": "Implement HP mutation, terminal state dispatch, and no-duplicate-failure trigger logic.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic state transition when HP reaches terminal threshold.",
            "testStrategy": "Unit tests verify single terminal dispatch and HP transitions.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add terminal-state replay and evidence checks",
            "description": "Add deterministic replay checks for castle-fall scenarios and evidence logging.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit terminal transition evidence and fail on missing terminal artifacts.",
            "testStrategy": "Regression tests verify consistent lose-condition timing under same seed.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 8,
        "title": "Develop win condition and game progression",
        "description": "Implement win condition (survive Day15) and integrate with day progression.",
        "details": "In GameStateManager, check if current day reaches 15 and castle HP > 0 to trigger win. Display win screen or message. Ensure it works with day/night cycles. Handle game end states (win/loss) appropriately, pausing or resetting as needed.",
        "testStrategy": "Play through to Day15 without losing to verify win triggers. Test loss condition precedence if castle HP=0 before Day15.",
        "priority": "low",
        "dependencies": [
          3,
          7
        ],
        "status": "pending",
        "subtasks": [],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 9,
        "title": "Create basic UI for day/night and HP display",
        "description": "Implement a minimal user interface to show current day, time in cycle, and castle HP.",
        "details": "Use Godot's Control nodes (e.g., Label) to create UI elements. Display current day (1-15), time remaining in current Day/Night cycle, and castle HP. Update UI in real-time via C# scripts. Keep it simple for core loop visibility.",
        "testStrategy": "Run game and verify UI updates correctly with day progression and HP changes. Test responsiveness during state transitions.",
        "priority": "low",
        "dependencies": [
          1,
          3,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define minimal HUD data contract",
            "description": "Define data contract for day/night state, castle HP, and essential runtime counters in HUD.",
            "status": "pending",
            "priority": "low",
            "dependencies": [],
            "details": "Lock HUD fields, refresh cadence, and error-state placeholders for baseline UI.",
            "testStrategy": "Contract tests verify required HUD fields and bindings.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement HUD binding and update flow",
            "description": "Bind core-loop state to HUD and ensure deterministic updates without stale values.",
            "status": "pending",
            "priority": "low",
            "dependencies": [
              "1"
            ],
            "details": "Wire event-driven updates from core loop into UI layer with clear ownership.",
            "testStrategy": "Scene tests verify HUD state reflects runtime transitions.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add HUD regression and fallback-state tests",
            "description": "Cover missing-data fallback and state-transition rendering correctness in UI tests.",
            "status": "pending",
            "priority": "low",
            "dependencies": [
              "2"
            ],
            "details": "Emit UI state diagnostics for transition points and invalid data handling.",
            "testStrategy": "Regression tests verify HUD continuity across day-night and damage events.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 10,
        "title": "Integrate and test full core loop",
        "description": "Combine all systems and test the complete core gameplay loop from start to win/loss.",
        "details": "Split this integration gate into deterministic verification slices to reduce execution risk. Integrate runtime loop, spawn channels, path fallback, and win/lose checks in staged order. Keep each slice independently runnable and log artifacts to logs/e2e and logs/ci.",
        "testStrategy": "Run staged integration tests per subtask, then run a full seeded end-to-end replay (Day1-Day15). Validate deterministic timeline, channel isolation, blocker fallback, boss count lock, and regression smoke logs.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Wire core-loop systems into one playable scene flow",
            "description": "Assemble state machine, budget engine, spawner, and HP terminal checks in a single runtime path.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "1",
              "2",
              "3",
              "4",
              "5"
            ],
            "details": "Connect Game.Core services through adapters; ensure update order is explicit and deterministic.",
            "testStrategy": "Scene-level smoke verifies day-night transitions, wave start, and terminal state dispatch.",
            "subtasks": []
          },
          {
            "id": 2,
            "title": "Add seeded replay checkpoints and timeline assertions",
            "description": "Persist seed+phase snapshots and compare expected checkpoints during integration runs.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "10.1",
              "6",
              "7"
            ],
            "details": "Emit deterministic checkpoints every major transition and assert timeline invariants.",
            "testStrategy": "Repeat same-seed run twice and assert equivalent checkpoint sequence.",
            "subtasks": []
          },
          {
            "id": 3,
            "title": "Verify path-block fallback under fully blocked maps",
            "description": "Force blocked-path scenarios and confirm nearest-blocker targeting remains active.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "10.1",
              "8"
            ],
            "details": "Build reproducible blocked fixtures with seeded ties and ensure fallback target selection never deadlocks.",
            "testStrategy": "Integration case validates fallback engagement and recovery to normal targeting.",
            "subtasks": []
          },
          {
            "id": 4,
            "title": "Lock boss-night consistency and channel isolation checks",
            "description": "Assert boss-night fixed count and verify elite/boss channels do not contaminate normal budget.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "10.2",
              "10.3",
              "9"
            ],
            "details": "Add assertions for fixed boss count and per-channel accounting boundaries.",
            "testStrategy": "Scenario tests cover normal/elite/boss nights and compare channel budgets independently.",
            "subtasks": []
          },
          {
            "id": 5,
            "title": "Publish integration evidence package for release gate",
            "description": "Export smoke logs, seeded replay summary, and failure triage traces to logs paths.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "10.4"
            ],
            "details": "Write consolidated artifacts for CI-style inspection and manual debugging handoff.",
            "testStrategy": "Checklist verifies logs exist and contain required fields for each core anchor.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 11,
        "title": "Refine baseline bootstrap with main-scene and structure standards",
        "description": "Refine the existing T1 project with stricter main-scene, startup bootstrap script, and folder standards.",
        "details": "Reuse the project created in T1 (no new project). Harden startup main scene bindings, standardize scripts/scenes/assets/config folders, and verify editor reopen stability. This task focuses on baseline quality hardening, not duplicate project initialization.",
        "testStrategy": "Run reopen/rebuild checks on the same T1 project root, verify main scene bootstrap persistence and folder standards. Reject if validation is performed on a newly recreated project.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define bootstrap refinement standards",
            "description": "Define canonical main-scene, folder layout, and startup script standards for baseline refinement.",
            "status": "pending",
            "priority": "high",
            "dependencies": [],
            "details": "Lock naming conventions and mandatory bootstrap assets on existing root.",
            "testStrategy": "Contract checks verify required bootstrap assets and scene configuration.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement refined bootstrap wiring",
            "description": "Apply main-scene and structure refinements while preserving canonical root invariants.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "1"
            ],
            "details": "Update startup wiring and folder structure without introducing secondary roots.",
            "testStrategy": "Integration smoke verifies refined startup flow and structure integrity.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add structure-regression and gate checks",
            "description": "Add checks that fail when refined standards regress or startup bindings are broken.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "2"
            ],
            "details": "Emit structure verification artifacts and fail on missing mandatory bootstrap parts.",
            "testStrategy": "Gate tests verify refined bootstrap standards remain enforced.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 12,
        "title": "Implement Core Resource System with Integer Safety",
        "description": "Create a resource management system for gold, iron, and population cap, ensuring integer-safe operations to prevent floating-point drift.",
        "details": "Define a ResourceManager class in C# using integers for gold, iron, and population cap. Initialize with starting values: gold=800, iron=150, pop-cap=50. Implement methods to add/subtract resources with bounds checking (e.g., no negative values). Use Godot's signals or events for UI updates. Store resources as int to avoid floating-point issues. Pseudo-code: public class ResourceManager { private int gold, iron, popCap; public bool TrySpend(int goldCost, int ironCost) { if (gold >= goldCost && iron >= ironCost) { gold -= goldCost; iron -= ironCost; return true; } return false; } }",
        "testStrategy": "Unit tests in C# using NUnit or similar: test initial values, addition/subtraction, edge cases (zero, negative attempts), and integer overflow prevention. Verify no floating-point usage in resource calculations.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define resource contracts and integer invariants",
            "description": "Define canonical resource fields and invariants for gold, iron, and population cap as integer-only data.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "11"
            ],
            "details": "Lock resource names, initial values, and invariant rules consumed by all economy systems.",
            "testStrategy": "Contract tests verify integer-only schemas and required invariant declarations.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "2",
            "title": "Implement integer-safe add/spend operations",
            "description": "Implement atomic add/spend methods with bounds checks and deterministic failure returns.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "12.1",
              "11"
            ],
            "details": "Enforce single-path mutation methods and remove any floating-point math from resource logic.",
            "testStrategy": "Unit tests verify valid mutation, insufficient-resource rejection, and invariant preservation.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "3",
            "title": "Integrate resource events for gameplay and UI",
            "description": "Publish deterministic resource change events to UI and gameplay consumers.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "12.2"
            ],
            "details": "Emit structured deltas and reasons to avoid consumer-side recomputation or hidden mutations.",
            "testStrategy": "Integration tests verify event ordering and payload integrity during rapid updates.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "4",
            "title": "Add overflow guards and snapshot-safe serialization",
            "description": "Add overflow protection and stable snapshot payloads for save/load compatibility.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "12.2"
            ],
            "details": "Protect arithmetic boundaries and provide deterministic serialization for current resource state.",
            "testStrategy": "Boundary tests cover max/min values and snapshot roundtrip parity.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "5",
            "title": "Build integer-safety regression test suite",
            "description": "Create tests that enforce integer-only operations and prevent float-based regressions.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "12.2",
              "12.4"
            ],
            "details": "Add static checks and runtime assertions that fail on non-integer resource math.",
            "testStrategy": "Suite fails if any resource path introduces float operations or invariant drift.",
            "subtasks": [],
            "parentId": "undefined"
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 13,
        "title": "Design and Implement Building System with Footprint Rules",
        "description": "Develop a building system that supports core buildings (castle, residence, mine, barracks, MG tower, wall, mine trap) with footprint rules and placement logic.",
        "details": "Create a Building base class in C# with properties: type, level, footprint size, HP, cost. Implement subclasses for each building type. Footprint rules: castle=4, barracks=2, MG tower=1, wall=1. Use a grid-based placement system in Godot (e.g., TileMap or custom grid). For walls, implement drag-line build mode and gate one-way logic (blocks path except at gates). Buildings should be placed only if footprint fits and resources are available. Pseudo-code: public class Building { public Vector2I footprint; public bool CanPlace(Grid grid) { return grid.IsAreaFree(position, footprint); } }",
        "testStrategy": "Test placement logic: valid/invalid positions, footprint collisions, resource deduction on build. Test wall drag-line building and gate functionality in-game. Use debug visuals to verify grid alignment.",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define building archetypes and footprint metadata",
            "description": "Define building type metadata including level, HP, cost, and footprint size rules.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "11",
              "12"
            ],
            "details": "Create canonical archetype definitions for castle, residence, mine, barracks, MG tower, wall, and mine trap.",
            "testStrategy": "Metadata tests verify required fields and footprint values match design constraints.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "2",
            "title": "Implement grid occupancy and placement validation",
            "description": "Implement grid occupancy checks and placement validation against footprint collisions.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "13.1",
              "12"
            ],
            "details": "Reject out-of-bounds, blocked, and overlapping placements with deterministic reason codes.",
            "testStrategy": "Placement tests cover valid placement, collision rejection, and boundary constraints.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "3",
            "title": "Implement wall drag-line and one-way gate behavior",
            "description": "Add drag-line wall building and gate logic that enforces one-way traversal constraints.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "13.2"
            ],
            "details": "Support continuous wall placement with gate segments while preserving pathing restrictions.",
            "testStrategy": "Scene tests verify drag-line placement, gate creation, and traversal direction rules.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "4",
            "title": "Integrate build transactions and resource deduction",
            "description": "Integrate placement with atomic resource deduction and rollback on failed placements.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "13.2",
              "12"
            ],
            "details": "Ensure placement and spend are transactional so resources remain unchanged when placement fails.",
            "testStrategy": "Transaction tests verify spend-on-success and full rollback-on-failure behavior.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "5",
            "title": "Add placement and gate-pathing verification suite",
            "description": "Create integration tests for footprint collisions, wall gates, and path-block outcomes.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "13.3",
              "13.4",
              "6"
            ],
            "details": "Cover blocked-path fallback interactions and validate deterministic tie handling in gate scenarios.",
            "testStrategy": "Integration suite verifies consistent results across repeated same-seed placement scenarios.",
            "subtasks": [],
            "parentId": "undefined"
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 14,
        "title": "Implement Economy and Tax System for Residences",
        "description": "Add economy features where residences generate gold tax every 15 seconds and provide population capacity.",
        "details": "Extend the Building system for Residence class. On placement, increase population cap (configurable). Use a timer in Godot (Timer node) to trigger tax every 15 seconds: add gold to ResourceManager. Config-driven values (e.g., tax amount per level). Ensure integer-safe operations. Pseudo-code: public class Residence : Building { private Timer taxTimer; public override void OnBuilt() { resourceManager.IncreasePopCap(popAmount); taxTimer = new Timer(); taxTimer.WaitTime = 15; taxTimer.Timeout += () => resourceManager.AddGold(taxAmount); } }",
        "testStrategy": "Unit tests for tax timing and gold addition. In-game test: place residence, verify population cap increase, and check gold increments every 15 seconds. Validate no floating-point drift in resource updates.",
        "priority": "medium",
        "dependencies": [
          12,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define economy and tax contract",
            "description": "Define residence tax cadence, integer resource flow, and debt-related guard conditions.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock tax tick interval, integer-only updates, and negative-gold handling expectations.",
            "testStrategy": "Contract tests validate tax cadence fields and integer invariants.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement residence tax runtime flow",
            "description": "Implement tax generation, resource updates, and deterministic economy event emission.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply integer-only tax mutations and deterministic update ordering per tick.",
            "testStrategy": "Unit tests verify tax accumulation and debt-state transitions.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add economy regression and audit coverage",
            "description": "Cover invalid config fallback, long-run economy consistency, and audit evidence outputs.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit structured economy traces for tax ticks and mutation reasons.",
            "testStrategy": "Regression tests verify repeatable tax outcomes under fixed seeds.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 15,
        "title": "Develop Upgrade and Repair System with Constraints",
        "description": "Create a system for building upgrades (max level 5, no skipping) and repairs, with economic rules and constraints.",
        "details": "Add upgrade and repair functionality to Building class. Upgrades: increase level up to 5, cannot skip levels, cost resources (config-driven). On upgrade completion, restore full HP. Repairs: cost gold only, total full repair cost = 50% of build cost, applied incrementally over time. Prevent upgrade and repair from running simultaneously (use a state enum). Implement queues or coroutines in Godot for progress. Pseudo-code: public enum BuildState { Idle, Upgrading, Repairing }; public bool StartUpgrade() { if (state == BuildState.Idle && level < 5) { state = BuildState.Upgrading; // Deduct cost, start timer } }",
        "testStrategy": "Test upgrade logic: level progression, resource costs, HP restoration. Test repair: cost calculation, incremental application, and conflict with upgrades. Verify integer safety and config-driven values.",
        "priority": "medium",
        "dependencies": [
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define upgrade-repair exclusivity rules",
            "description": "Define upgrade levels, repair cost model, and mutual-exclusion constraints between repair and upgrade.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock cannot-repair-while-upgrading behavior and full-heal-on-upgrade completion rule.",
            "testStrategy": "Contract tests validate upgrade/repair exclusivity and level constraints.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement upgrade and repair execution flow",
            "description": "Implement queueing, resource deduction, cancellation policy, and progression timing for upgrades and repairs.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply integer-only cost deduction with cancel/refund rules and deterministic timing.",
            "testStrategy": "Unit tests verify queue transitions, refunds, and completion effects.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add repair-upgrade regression scenarios",
            "description": "Cover debt-stop repair, cancel behaviors, and edge-case transitions with deterministic assertions.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit upgrade/repair timeline evidence and reject illegal concurrent actions.",
            "testStrategy": "Regression tests verify exclusivity and recovery paths across edge cases.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 16,
        "title": "Implement Unit Training Queue in Barracks",
        "description": "Add unit training functionality to barracks with a single queue per barracks, cancellable with 100% refund.",
        "details": "Create a Barracks class extending Building. Implement a training queue (List or Queue in C#) for units. Each barracks has its own queue. Training consumes resources over time (config-driven). Allow cancellation of any queued unit with 100% refund to resources. Use Godot's signals for UI updates. Pseudo-code: public class Barracks : Building { private Queue<UnitTrainingJob> trainingQueue; public void CancelTraining(int index) { var job = trainingQueue[index]; resourceManager.Refund(job.cost); trainingQueue.RemoveAt(index); } }",
        "testStrategy": "Unit tests for queue operations, resource deduction/refund on cancel. In-game test: train multiple units, cancel mid-training, verify refund accuracy and queue state. Ensure integer safety.",
        "priority": "medium",
        "dependencies": [
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define barracks queue contract",
            "description": "Define per-barracks queue constraints, slot behavior, and resource-deduction timing rules.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock one-queue-per-barracks rule and immediate cost deduction semantics.",
            "testStrategy": "Contract tests verify queue limits and deduction timing constraints.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement training queue runtime",
            "description": "Implement enqueue, cancel/refund, and completion flows for unit training per barracks.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic queue progression and per-queue ownership boundaries.",
            "testStrategy": "Unit tests verify queue order, cancel refunds, and completion dispatch.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add queue stress and regression tests",
            "description": "Cover rapid enqueue/cancel sequences and multi-barracks isolation scenarios.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit queue diagnostics for ordering and state transitions under load.",
            "testStrategy": "Regression tests verify deterministic queue behavior in stress cases.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 17,
        "title": "Design and Integrate Tech Tree for Unit Stats",
        "description": "Develop a config-driven tech tree that affects unit stats (atk speed %, damage, production speed %, range, HP, cost %).",
        "details": "Create a TechTreeManager class that loads tech definitions from JSON config. Each tech node modifies unit stats multiplicatively (e.g., damage * 1.1 for 10% increase). Apply effects to units trained from barracks. Ensure no hardcoded unlock paths; unlocks are config-driven. Use Godot's resource system for config files. Pseudo-code: public class TechTreeManager { private Dictionary<string, TechNode> nodes; public float GetStatMultiplier(string stat) { // Calculate based on unlocked techs } }",
        "testStrategy": "Test config loading and parsing. Unit tests for stat multiplier calculations. In-game test: unlock techs, train units, verify stat changes match config. Ensure all unlocks are configurable.",
        "priority": "medium",
        "dependencies": [
          13,
          16
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define tech-tree stat modifier contract",
            "description": "Define tech stat categories, integer/percentage boundaries, and stack application order.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock tech modifier schema and out-of-range rejection behavior for percentage-based stats.",
            "testStrategy": "Contract tests verify modifier bounds and deterministic apply order.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement tech application runtime",
            "description": "Apply tech modifiers to unit stats and production parameters using deterministic update rules.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Ensure tech effects propagate through runtime snapshots without hardcoded constants.",
            "testStrategy": "Unit tests verify expected stat outputs after tech changes.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add tech regression and balancing checks",
            "description": "Add tests for cap enforcement, reset/load consistency, and replay-safe outcomes.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit tech application traces and reject out-of-range modifier inputs.",
            "testStrategy": "Regression tests verify deterministic tech impact under fixed seeds.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 18,
        "title": "Implement Reward System with Nightly Choices",
        "description": "Add a reward system that triggers each night, offering 3 choices from separate pools, with fallback to gold if pool is exhausted.",
        "details": "Create a RewardManager class. Each night (based on day/night cycle), trigger a reward event. Generate 3 choices from a pool specific to night type (config-driven). Pools are defined in JSON; if a pool is empty, fallback to granting a fixed gold amount. Choices can include resources, units, or bonuses. Use Godot's UI to present choices. Pseudo-code: public class RewardManager { public void OnNightStart() { var choices = GetThreeChoices(nightPool); if (choices.Count == 0) resourceManager.AddGold(fallbackGold); } }",
        "testStrategy": "Unit tests for choice generation, pool exhaustion, and fallback logic. In-game test: progress through nights, verify rewards appear correctly and fallback works. Validate config-driven pools.",
        "priority": "low",
        "dependencies": [
          12,
          14
        ],
        "status": "pending",
        "subtasks": [],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 19,
        "title": "Add Day/Night Cycle and Game Win/Lose Conditions",
        "description": "Implement the day/night cycle (4 min Day + 2 min Night, Day1-Day15) and win/lose conditions based on castle HP.",
        "details": "Create a GameManager class to handle game state. Use a timer for day/night cycle: 4 minutes day, 2 minutes night, repeat for 15 days. Track current day and time. Win condition: survive to Day15. Lose condition: castle HP = 0. Integrate with Building system to monitor castle HP. Use Godot's signals for UI updates (e.g., day counter). Pseudo-code: public class GameManager { private int currentDay = 1; private Timer cycleTimer; public void CheckWinLose() { if (currentDay > 15) Win(); if (castle.HP <= 0) Lose(); } }",
        "testStrategy": "Test day/night timing accuracy. Unit tests for win/lose conditions. In-game test: play through cycles, destroy castle to trigger lose, survive to Day15 to win. Verify match duration target (60-90 minutes) is achievable.",
        "priority": "high",
        "dependencies": [
          11,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define cycle scheduler and deterministic clock contract",
            "description": "Define scheduler interfaces for 4-minute Day and 2-minute Night with deterministic tick ownership.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "11"
            ],
            "details": "Specify timing ownership, transition events, and day counter boundaries for Day1-Day15.",
            "testStrategy": "Contract tests verify scheduler emits expected phase events and day boundaries.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "2",
            "title": "Implement Day1-Day15 cycle progression",
            "description": "Implement cycle transitions and day progression across Day and Night phases through Day15.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "19.1",
              "3"
            ],
            "details": "Bind scheduler to runtime updates and ensure phase changes stay aligned with configured durations.",
            "testStrategy": "Progression tests verify exact day increment boundaries and phase durations.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "3",
            "title": "Implement win/lose evaluator against castle HP",
            "description": "Implement terminal evaluator: win on surviving through Day15, lose when castle HP reaches zero.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "19.2",
              "13",
              "7"
            ],
            "details": "Guarantee a single terminal result and lock state updates after terminal resolution.",
            "testStrategy": "Terminal tests verify lose-before-Day15 and survive-Day15 scenarios with exclusive outcomes.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "4",
            "title": "Integrate cycle and terminal events with UI state",
            "description": "Wire cycle and terminal events to UI counters, warnings, and end-state presentation.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "19.3",
              "9"
            ],
            "details": "Update day counters, phase indicators, and terminal prompts using stable event payloads.",
            "testStrategy": "UI integration tests verify event-to-display consistency through transitions and terminal events.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "5",
            "title": "Add end-to-end scenario coverage for cycle outcomes",
            "description": "Add scenario tests that cover full-cycle progression and both terminal branches.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "19.2",
              "19.3",
              "19.4"
            ],
            "details": "Run deterministic scenarios to validate schedule accuracy and win/lose correctness together.",
            "testStrategy": "Scenario suite passes only when cycle timings and terminal outcomes are both correct.",
            "subtasks": [],
            "parentId": "undefined"
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 20,
        "title": "Integrate Combat with Friendly Fire Disabled",
        "description": "Implement combat system for units and towers, with friendly fire disabled for all player attacks.",
        "details": "Create a CombatSystem class. Units and MG towers can attack enemies. Use Godot's physics or area detection for targeting. Implement attack logic: damage calculation based on stats (from tech tree). Ensure friendly fire is disabled: player-owned units cannot damage other player-owned units or buildings. This can be done by checking team IDs or ownership flags. Pseudo-code: public void Attack(Unit attacker, Unit target) { if (attacker.team == target.team) return; // Friendly fire disabled // Apply damage }",
        "testStrategy": "Unit tests for attack logic and friendly fire prevention. In-game test: spawn player units and enemies, verify attacks only hit enemies. Test with MG towers and walls. Ensure config-driven stats are applied.",
        "priority": "medium",
        "dependencies": [
          13,
          16,
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define combat resolution contract",
            "description": "Define damage resolution, target selection constraints, and no-friendly-fire invariant.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock combat event payload and friendly-fire disabled policy across all units/towers.",
            "testStrategy": "Contract tests verify combat payload fields and friendly-fire invariants.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement combat integration flow",
            "description": "Integrate unit/tower attacks with target resolution and deterministic combat tick ordering.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic combat tick sequencing and ignore friendly entities in damage paths.",
            "testStrategy": "Unit tests verify target resolution and damage application order.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add combat regression and edge-case coverage",
            "description": "Cover mixed-unit scenarios, elite/boss fights, and no-friendly-fire guarantees.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit combat diagnostics for target picks and damage events.",
            "testStrategy": "Regression tests verify no-friendly-fire under dense engagements.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 21,
        "title": "Lock Windows export profile and Steam runtime startup validation",
        "description": "On top of T11, lock Windows-only export profile and validate Steam runtime startup path for single-player mode.",
        "status": "pending",
        "dependencies": [
          11
        ],
        "priority": "high",
        "details": "Reuse the hardened project from T11 (no re-bootstrap). Finalize Windows-only export configuration, disable online dependencies for single-player path, and verify Steam runtime startup compatibility. This task owns platform/runtime validation only.",
        "testStrategy": "Validate Windows export artifact and Steam runtime startup flow on the same project root from T11; fail if any step depends on a newly created project or bypasses Steam runtime launch checks.",
        "subtasks": [
          {
            "id": "1",
            "title": "Define Windows export and Steam startup contract",
            "description": "Define required Windows export profile fields and Steam runtime startup validation checkpoints.",
            "status": "pending",
            "priority": "high",
            "dependencies": [],
            "details": "Lock export preset invariants and startup validation criteria on Windows-only target.",
            "testStrategy": "Contract checks verify export profile keys and startup validation prerequisites.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement export profile lock and startup checks",
            "description": "Implement validation logic for export profile integrity and Steam startup preflight.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "1"
            ],
            "details": "Apply fail-fast checks when profile or startup prerequisites are missing.",
            "testStrategy": "Integration checks verify startup validation path on Windows runtime.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add export/startup gate regression tests",
            "description": "Cover corrupted profile, missing fields, and startup failure-path diagnostics.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "2"
            ],
            "details": "Emit structured export/startup evidence and reject invalid release inputs.",
            "testStrategy": "Gate tests verify release blocking behavior for invalid profiles.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 22,
        "title": "Implement Camera and Interaction System with Edge and Keyboard Scrolling",
        "description": "Develop camera controls for edge scrolling and keyboard-based scrolling in the game world.",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "high",
        "details": "Create a CameraController node with a Camera2D. Implement edge scrolling: detect mouse position near screen edges (e.g., within 20 pixels) and move camera accordingly. Add keyboard scrolling using arrow keys or WASD. Configure camera limits to match game world boundaries. Ensure smooth movement with adjustable speed. Use Godot's input system for keyboard and mouse events.\n\nPseudo-code:\n// CameraController.cs\npublic partial class CameraController : Node2D\n{\n    private Camera2D _camera;\n    private float _scrollSpeed = 500f;\n    private int _edgeMargin = 20;\n\n    public override void _Ready() {\n        _camera = GetNode<Camera2D>(\"Camera2D\");\n    }\n\n    public override void _Process(double delta) {\n        Vector2 move = Vector2.Zero;\n        // Edge scrolling\n        Vector2 mousePos = GetViewport().GetMousePosition();\n        if (mousePos.X < _edgeMargin) move.X -= 1;\n        if (mousePos.X > GetViewport().GetVisibleRect().Size.X - _edgeMargin) move.X += 1;\n        if (mousePos.Y < _edgeMargin) move.Y -= 1;\n        if (mousePos.Y > GetViewport().GetVisibleRect().Size.Y - _edgeMargin) move.Y += 1;\n        // Keyboard scrolling\n        if (Input.IsActionPressed(\"ui_right\")) move.X += 1;\n        if (Input.IsActionPressed(\"ui_left\")) move.X -= 1;\n        if (Input.IsActionPressed(\"ui_down\")) move.Y += 1;\n        if (Input.IsActionPressed(\"ui_up\")) move.Y -= 1;\n        _camera.Position += move.Normalized() * _scrollSpeed * (float)delta;\n    }\n}",
        "testStrategy": "Test in-game: move mouse to screen edges and verify camera scrolls. Press arrow keys/WASD to confirm keyboard scrolling. Check camera limits prevent moving beyond world bounds. Ensure no performance issues.",
        "subtasks": [
          {
            "id": "1",
            "title": "Define camera movement and bounds contract",
            "description": "Define edge-scroll, keyboard-scroll, lock behavior, and world-bounds constraints.",
            "status": "pending",
            "priority": "high",
            "dependencies": [],
            "details": "Lock movement speeds, bounds clamping, and lock-state interaction rules.",
            "testStrategy": "Contract tests verify movement parameters and bounds invariants.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement camera edge/keyboard scroll runtime",
            "description": "Implement edge and keyboard camera control with deterministic clamping and lock handling.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "1"
            ],
            "details": "Apply stable movement updates across paused and active runtime states.",
            "testStrategy": "Scene tests verify camera movement, lock, and bounds behavior.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add camera regression and usability checks",
            "description": "Cover focus loss, rapid input switching, and boundary stress scenarios.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "2"
            ],
            "details": "Emit camera state diagnostics for movement mode transitions.",
            "testStrategy": "Regression tests verify no boundary escape and consistent movement response.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 23,
        "title": "Develop Runtime Speed Controls (Pause, 1x, 2x) with Timer Freeze",
        "description": "Implement game speed controls including pause, 1x, and 2x speeds, ensuring all timers freeze during pause.",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "high",
        "details": "Create a GameManager singleton to manage game state and speed. Implement pause functionality that sets Engine.TimeScale to 0 and freezes all custom timers. For 1x and 2x speeds, set TimeScale to 1 and 2 respectively. Ensure that during pause, any queued countdowns (e.g., wave timers) are paused and resume correctly. Use Godot's ProcessMode to handle pausing of nodes. Add UI buttons to control speed.\n\nPseudo-code:\n// GameManager.cs\npublic partial class GameManager : Node\n{\n    public static GameManager Instance;\n    private float _currentSpeed = 1f;\n    private bool _isPaused = false;\n\n    public override void _Ready() {\n        Instance = this;\n    }\n\n    public void SetSpeed(float speed) {\n        if (_isPaused && speed > 0) _isPaused = false;\n        Engine.TimeScale = speed;\n        _currentSpeed = speed;\n        // Notify all timers to adjust\n    }\n\n    public void TogglePause() {\n        _isPaused = !_isPaused;\n        if (_isPaused) {\n            Engine.TimeScale = 0;\n            // Freeze all custom timers\n        } else {\n            Engine.TimeScale = _currentSpeed;\n            // Unfreeze timers\n        }\n    }\n}",
        "testStrategy": "Test pause: start a timer, pause game, verify timer stops and no gameplay progresses. Unpause and confirm timer resumes. Switch between 1x and 2x speeds, check game speed changes accordingly. Validate UI buttons work and update state.",
        "subtasks": [
          {
            "id": "1",
            "title": "Define speed-control and freeze semantics",
            "description": "Define pause/1x/2x semantics and full timer freeze behavior for gameplay systems.",
            "status": "pending",
            "priority": "high",
            "dependencies": [],
            "details": "Lock which timers freeze and which systems remain deterministic under speed changes.",
            "testStrategy": "Contract tests verify speed-state matrix and freeze invariants.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement runtime speed switching",
            "description": "Implement pause/1x/2x switching and propagate speed state across timing-dependent systems.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic propagation of speed state to loop, spawn, and queue timers.",
            "testStrategy": "Unit tests verify timer behavior under all speed states.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add speed-control regression and replay checks",
            "description": "Cover rapid toggles, pause-resume cycles, and replay consistency under speed changes.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "2"
            ],
            "details": "Emit speed-state timeline evidence for debugging and gate checks.",
            "testStrategy": "Regression tests verify deterministic timeline anchors across speed changes.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 24,
        "title": "Create UI Feedback System for Invalid Actions and Errors",
        "description": "Implement UI feedback for invalid placement, blocked actions, and migration/load errors with clear user-facing messages.",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "medium",
        "details": "Design a UIFeedbackManager that displays messages via a label or popup. For invalid placement (e.g., building on invalid terrain), show a temporary message like \"Cannot build here.\" For blocked actions, display reason. For migration/load errors, show a persistent error dialog with details. Use Godot's Control nodes for UI. Ensure messages are non-intrusive and dismissible. Integrate with game events to trigger feedback.\n\nPseudo-code:\n// UIFeedbackManager.cs\npublic partial class UIFeedbackManager : Control\n{\n    private Label _feedbackLabel;\n    private Timer _hideTimer;\n\n    public override void _Ready() {\n        _feedbackLabel = GetNode<Label>(\"FeedbackLabel\");\n        _hideTimer = GetNode<Timer>(\"HideTimer\");\n        _hideTimer.Timeout += HideFeedback;\n    }\n\n    public void ShowFeedback(string message, bool isError = false) {\n        _feedbackLabel.Text = message;\n        _feedbackLabel.Modulate = isError ? Colors.Red : Colors.Yellow;\n        _feedbackLabel.Visible = true;\n        _hideTimer.Start(3.0); // Hide after 3 seconds\n    }\n\n    private void HideFeedback() {\n        _feedbackLabel.Visible = false;\n    }\n}",
        "testStrategy": "Simulate invalid placement: attempt to build in a blocked area, verify feedback appears. Test load error by corrupting a save file, check error dialog shows. Ensure messages are clear and UI updates correctly. Validate timing and visibility.",
        "subtasks": [
          {
            "id": "1",
            "title": "Define invalid-action feedback contract",
            "description": "Define error categories, message keys, and display priorities for invalid actions.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock feedback reason codes and i18n-friendly key usage for UI messages.",
            "testStrategy": "Contract tests verify reason-code to message-key mapping completeness.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement runtime feedback dispatch flow",
            "description": "Implement dispatch of invalid-action and error messages from gameplay logic to UI.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic message routing with de-dup and clear user-facing priority rules.",
            "testStrategy": "Scene tests verify message rendering for invalid actions and errors.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add feedback regression and localization checks",
            "description": "Cover repeated invalid inputs, boundary errors, and localization key fallback behavior.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit feedback diagnostics with reason codes for troubleshooting.",
            "testStrategy": "Regression tests verify stable feedback behavior across repeated errors.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 25,
        "title": "Build Save System with Autosave and Migration Handling",
        "description": "Develop a save system with one autosave slot, start-of-day autosaves, and migration for invalid configs/loads.",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "high",
        "details": "Create a SaveManager that handles saving and loading game state to a file. Use a single autosave slot (e.g., autosave.save). Implement autosave at the start of each day. For migration, check save file version; if incompatible, reject load and show error. Save data should include game state, seed, wave timer, etc. Use JSON or binary serialization. Ensure safe file operations on Windows.\n\nPseudo-code:\n// SaveManager.cs\npublic partial class SaveManager : Node\n{\n    private string _savePath = \"user://autosave.save\";\n    private int _currentVersion = 1;\n\n    public void SaveGame(GameState state) {\n        var saveData = new SaveData { Version = _currentVersion, State = state };\n        string json = Json.Stringify(saveData);\n        FileAccess file = FileAccess.Open(_savePath, FileAccess.ModeFlags.Write);\n        file.StoreString(json);\n        file.Close();\n    }\n\n    public GameState LoadGame() {\n        if (!FileAccess.FileExists(_savePath)) return null;\n        FileAccess file = FileAccess.Open(_savePath, FileAccess.ModeFlags.Read);\n        string json = file.GetAsText();\n        file.Close();\n        var saveData = Json.ParseString<SaveData>(json);\n        if (saveData.Version != _currentVersion) {\n            // Trigger migration error via UIFeedbackManager\n            return null;\n        }\n        return saveData.State;\n    }\n}",
        "testStrategy": "Test save: play game, trigger autosave, verify file is created. Load game, confirm state is restored. Test migration: modify save version, attempt load, check error is shown. Validate file paths and error handling.",
        "subtasks": [
          {
            "id": "1",
            "title": "Define SaveData contract and versioned payload model",
            "description": "Define versioned SaveData payload including game state, seed, wave timer, and required metadata fields.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "21"
            ],
            "details": "Lock payload schema and serialization format ownership for the single autosave slot.",
            "testStrategy": "Contract tests verify required fields and version field presence in serialized payloads.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "2",
            "title": "Implement single-slot autosave writer on day start",
            "description": "Implement autosave writing to user://autosave.save triggered at day-start boundaries.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "25.1",
              "19"
            ],
            "details": "Ensure first autosave creates file and subsequent saves overwrite the same slot deterministically.",
            "testStrategy": "Autosave tests verify create-on-first-trigger and overwrite-on-later-triggers behavior.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "3",
            "title": "Implement load path with IO and corruption handling",
            "description": "Implement load behavior for missing file, read failure, and corrupt payload with explicit failure outcomes.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "25.1"
            ],
            "details": "Reject partial state application and keep runtime state unchanged on all load failures.",
            "testStrategy": "Negative tests cover missing file, read error, and invalid payload with no partial apply.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "4",
            "title": "Implement migration gate for version mismatch",
            "description": "Validate save version before state apply and reject incompatible versions with user feedback.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "25.3",
              "22"
            ],
            "details": "Apply migration rejection policy before any field mutation and emit explicit migration error reason.",
            "testStrategy": "Migration tests assert incompatible version rejects load and leaves runtime state unchanged.",
            "subtasks": [],
            "parentId": "undefined"
          },
          {
            "id": "5",
            "title": "Build save/load verification and audit evidence suite",
            "description": "Add roundtrip and failure-path tests with auditable evidence for release gate checks.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "25.2",
              "25.3",
              "25.4"
            ],
            "details": "Cover valid roundtrip, missing file, IO failure, corruption, and version mismatch in one gate suite.",
            "testStrategy": "Suite must prove deterministic outcomes and required audit fields for each path.",
            "subtasks": [],
            "parentId": "undefined"
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 26,
        "title": "Integrate Steam Cloud Save with Account Binding",
        "description": "Implement Steam cloud save functionality using Steam account binding for save data synchronization.",
        "status": "pending",
        "dependencies": [
          25
        ],
        "priority": "medium",
        "details": "Use Steamworks.NET or GodotSteam plugin to integrate Steam API. Bind saves to the user's Steam account. On save, upload the save file to Steam Cloud; on load, download from cloud. Handle conflicts (e.g., local vs. cloud) by prompting user. Ensure compatibility with the existing SaveManager. Test with Steamworks API in a development environment.\n\nPseudo-code:\n// SteamCloudManager.cs\npublic partial class SteamCloudManager : Node\n{\n    public async Task UploadSave(string filePath) {\n        if (SteamManager.IsLoggedIn) {\n            byte[] data = File.ReadAllBytes(filePath);\n            bool success = SteamRemoteStorage.FileWrite(\"autosave.save\", data);\n            if (!success) Debug.Log(\"Upload failed\");\n        }\n    }\n\n    public async Task DownloadSave(string filePath) {\n        if (SteamRemoteStorage.FileExists(\"autosave.save\")) {\n            byte[] data = SteamRemoteStorage.FileRead(\"autosave.save\");\n            File.WriteAllBytes(filePath, data);\n        }\n    }\n}",
        "testStrategy": "Test with a Steam development account: save game, verify file uploads to cloud. Restart game, load from cloud, confirm data matches. Simulate network issues, check error handling. Ensure account binding works.",
        "subtasks": [
          {
            "id": "1",
            "title": "Define Steam cloud-save binding contract",
            "description": "Define account binding constraints, slot policy, and cloud/local consistency rules.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock Steam account identity checks and single auto-save slot behavior.",
            "testStrategy": "Contract tests verify account-bound save identity and slot constraints.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement cloud-save sync and validation",
            "description": "Implement cloud upload/download flow, binding validation, and conflict handling.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic save metadata checks and strict rejection on invalid ownership.",
            "testStrategy": "Integration tests verify cloud sync and ownership validation flow.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add cloud-save regression and failure recovery tests",
            "description": "Cover offline fallback, account mismatch, and corrupted payload rejection paths.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit structured save-sync diagnostics and fail-safe recovery evidence.",
            "testStrategy": "Regression tests verify deterministic recovery and rejection behavior.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 27,
        "title": "Implement Achievements System with Deterministic Unlocking",
        "description": "Create an achievements system with a visible list, non-hidden achievements, and deterministic unlock triggers.",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "medium",
        "details": "Design an AchievementManager that tracks achievement progress. Define achievements in a config file (e.g., JSON) with IDs, names, descriptions, and unlock conditions. Achievements should be visible from the start (non-hidden). Unlock triggers must be deterministic based on game events (e.g., survive day 15). Use Steamworks API for Steam achievements if integrated. Update UI to show achievement list and unlock notifications.\n\nPseudo-code:\n// AchievementManager.cs\npublic partial class AchievementManager : Node\n{\n    private Dictionary<string, Achievement> _achievements;\n\n    public override void _Ready() {\n        LoadAchievementsFromConfig();\n    }\n\n    public void UnlockAchievement(string id) {\n        if (_achievements.ContainsKey(id) && !_achievements[id].IsUnlocked) {\n            _achievements[id].IsUnlocked = true;\n            // Update Steam achievement\n            SteamUserStats.SetAchievement(id);\n            SteamUserStats.StoreStats();\n            // Show UI notification\n        }\n    }\n}",
        "testStrategy": "Test unlocking: trigger an achievement condition (e.g., win game), verify achievement unlocks and UI updates. Check achievement list displays correctly. Ensure determinism by repeating same actions. Validate Steam integration if used.",
        "subtasks": [
          {
            "id": "1",
            "title": "Define achievement trigger contract",
            "description": "Define achievement IDs, deterministic trigger conditions, and persistence boundaries.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock trigger conditions and one-time unlock behavior for all visible achievements.",
            "testStrategy": "Contract tests verify achievement key set and trigger condition completeness.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement deterministic unlock pipeline",
            "description": "Implement runtime trigger evaluation, unlock persistence, and event dispatch.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic unlock ordering and idempotent save behavior.",
            "testStrategy": "Unit tests verify unlock criteria and duplicate-trigger protection.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add achievement regression and sync tests",
            "description": "Cover replay consistency, load-resume behavior, and Steam sync edge cases.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit achievement unlock evidence with deterministic timestamps/sequence anchors.",
            "testStrategy": "Regression tests verify consistent unlock outcomes under repeated runs.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 28,
        "title": "Set Up Localization (i18n) for zh-CN and en-US",
        "description": "Implement key-based internationalization workflow supporting zh-CN and en-US at launch.",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "medium",
        "details": "Create a LocalizationManager that loads translation files (e.g., CSV or JSON) for each language. Use keys for text references (e.g., \"UI_PAUSE\"). Support zh-CN and en-US. Implement language switching in settings. Ensure i18n keys remain stable across patches. Integrate with UI elements to update text dynamically. Store language preference in config.\n\nPseudo-code:\n// LocalizationManager.cs\npublic partial class LocalizationManager : Node\n{\n    private Dictionary<string, string> _translations;\n    private string _currentLanguage = \"en-US\";\n\n    public void LoadLanguage(string lang) {\n        string filePath = $\"res://locales/{lang}.json\";\n        var file = FileAccess.Open(filePath, FileAccess.ModeFlags.Read);\n        string json = file.GetAsText();\n        _translations = Json.ParseString<Dictionary<string, string>>(json);\n        file.Close();\n        _currentLanguage = lang;\n        // Notify UI to update\n    }\n\n    public string Tr(string key) {\n        return _translations.GetValueOrDefault(key, key);\n    }\n}",
        "testStrategy": "Test language switching: load en-US and zh-CN, verify UI text changes. Check missing keys fallback to key. Validate translation files are loaded correctly. Ensure keys are stable and don't change unintentionally.",
        "subtasks": [
          {
            "id": "1",
            "title": "Define i18n resource and key contract",
            "description": "Define zh-CN/en-US baseline keys, namespace conventions, and fallback behavior.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock message-key conventions and non-hardcoded text usage requirements.",
            "testStrategy": "Contract tests verify required key coverage for both baseline locales.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement localization loading and runtime switching",
            "description": "Implement locale resource loading, key resolution, and runtime language switching.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic fallback to key literal when keys are missing.",
            "testStrategy": "Scene tests verify locale switch updates core UI text correctly.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add i18n regression and key-audit tests",
            "description": "Cover missing keys, fallback correctness, and persisted locale preference behavior.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit localization diagnostics for unresolved keys and fallback paths.",
            "testStrategy": "Regression tests verify stable key resolution across reloads.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 29,
        "title": "Add Audio Settings for Music and SFX Channels",
        "description": "Implement audio settings to control music and sound effects volume at launch.",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "low",
        "details": "Create an AudioManager that handles music and SFX playback. Add settings in UI to adjust volume sliders for music and SFX channels. Save audio preferences to config file. Use Godot's AudioStreamPlayer nodes. Ensure settings apply immediately and persist between sessions.\n\nPseudo-code:\n// AudioManager.cs\npublic partial class AudioManager : Node\n{\n    private AudioStreamPlayer _musicPlayer;\n    private AudioStreamPlayer _sfxPlayer;\n    private float _musicVolume = 1.0f;\n    private float _sfxVolume = 1.0f;\n\n    public override void _Ready() {\n        _musicPlayer = GetNode<AudioStreamPlayer>(\"MusicPlayer\");\n        _sfxPlayer = GetNode<AudioStreamPlayer>(\"SFXPlayer\");\n        LoadSettings();\n    }\n\n    public void SetMusicVolume(float volume) {\n        _musicVolume = volume;\n        _musicPlayer.VolumeDb = LinearToDb(volume);\n        SaveSettings();\n    }\n}",
        "testStrategy": "Test volume sliders: adjust music and SFX, verify audio levels change. Save and reload game, check settings persist. Play sounds to ensure channels work independently. Validate no audio glitches.",
        "subtasks": [],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 30,
        "title": "Optimize for Performance Targets (45 FPS 1% Low, 60 FPS Average)",
        "description": "Implement optimizations to meet non-functional goals: low-end baseline 45 FPS (1% low) and average 60 FPS target.",
        "status": "pending",
        "dependencies": [
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29
        ],
        "priority": "high",
        "details": "Decompose performance optimization into measurable phases: baseline capture, hotspot isolation, frame-budget remediation, stress validation, and gate artifact output. Keep all thresholds integer and reproducible in Windows headless/playable runs.",
        "testStrategy": "Run phased perf suites with fixed seed scenes; compare 1% low and average FPS against baselines. Emit summary artifacts under logs/perf and logs/ci for gate review.",
        "subtasks": [
          {
            "id": 1,
            "title": "Capture deterministic baseline performance profiles",
            "description": "Collect 1% low/average FPS baseline from fixed-seed scenarios and store reproducible traces.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "21",
              "22",
              "23"
            ],
            "details": "Use locked camera paths and scripted sessions to produce comparable baseline measurements.",
            "testStrategy": "Two repeated runs must remain within acceptable variance windows.",
            "subtasks": []
          },
          {
            "id": 2,
            "title": "Identify and classify frame-time hotspots",
            "description": "Find CPU/GPU and script hotspots affecting frame stability in combat-heavy scenes.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "30.1"
            ],
            "details": "Tag hotspots by subsystem (AI, spawn, render, UI) and quantify impact before optimization.",
            "testStrategy": "Profiling report must rank top offenders with repeatable timing data.",
            "subtasks": []
          },
          {
            "id": 3,
            "title": "Apply targeted optimizations under config-safe constraints",
            "description": "Implement focused fixes without breaking deterministic behavior or config governance.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "30.2",
              "24",
              "25",
              "26"
            ],
            "details": "Optimize update loops, pooling, and expensive queries while preserving gameplay semantics.",
            "testStrategy": "Regression suite confirms behavior parity and measurable frame-time improvement.",
            "subtasks": []
          },
          {
            "id": 4,
            "title": "Run stress and endurance validation at launch presets",
            "description": "Validate thresholds under high-pressure waves and long-session stability conditions.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "30.3",
              "27",
              "28",
              "29"
            ],
            "details": "Execute worst-case wave mixes and UI-heavy scenarios; watch memory growth and stutter spikes.",
            "testStrategy": "Stress report shows thresholds satisfied or clear fail reasons with traces.",
            "subtasks": []
          },
          {
            "id": 5,
            "title": "Publish performance gate evidence package",
            "description": "Export final metrics, comparisons, and gate decision artifacts for release readiness.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "30.4"
            ],
            "details": "Write standardized summary files to logs/perf and logs/ci with threshold verdicts.",
            "testStrategy": "Checklist verifies required artifacts and threshold fields are complete.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 31,
        "title": "Scaffold config-contract workspace on existing project",
        "description": "Extend the existing project with config schema/sample workspace structure for contract-driven tuning.",
        "details": "Reuse the validated project from T21. Add config/schemas and config/samples workspace, plus config contract README and wiring entrypoints. This task must not recreate or reinitialize the Godot project.",
        "testStrategy": "Verify new config workspace paths and contract entrypoints exist and are wired in the existing project root inherited from T21. Fail if setup is executed by creating another standalone project.",
        "priority": "high",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define config-workspace conventions",
            "description": "Define schema locations, naming conventions, and version field rules for config workspace.",
            "status": "pending",
            "priority": "high",
            "dependencies": [],
            "details": "Lock canonical config paths and naming standards for all contract files.",
            "testStrategy": "Contract checks verify workspace structure and required metadata fields.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement workspace scaffold on existing root",
            "description": "Create/update config contract directories and bootstrap baseline manifests without changing core architecture.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "1"
            ],
            "details": "Apply non-destructive scaffold updates compatible with current repository layout.",
            "testStrategy": "Structure tests verify required files/directories exist and are discoverable.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add scaffold regression and guard checks",
            "description": "Cover missing-file detection, duplicate-path prevention, and bootstrap idempotency.",
            "status": "pending",
            "priority": "high",
            "dependencies": [
              "2"
            ],
            "details": "Emit scaffold evidence for CI-friendly verification and troubleshooting.",
            "testStrategy": "Regression tests verify repeated scaffold runs remain idempotent.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 32,
        "title": "Implement enemy-config.schema.json with validation rules",
        "description": "Define JSON schema for enemy configuration, including fields for enemy types, stats, and behaviors, adhering to config-first balancing and no hardcoded values.",
        "details": "Create enemy-config.schema.json in config/schemas/. Define schema with properties: enemy_id (string), health (number min 1), damage (number min 0), speed (number min 0), etc. Include required fields and type constraints. Use JSON Schema draft-07. Ensure all balance values are configurable. Pseudo-code: { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"type\": \"object\", \"properties\": { \"enemies\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"enemy_id\": { \"type\": \"string\" }, \"health\": { \"type\": \"number\", \"minimum\": 1 } } } } } }.",
        "testStrategy": "Validate schema against a test JSON file using a JSON schema validator (e.g., Newtonsoft.Json.Schema in C#). Ensure it rejects invalid types or missing required fields.",
        "priority": "high",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": [],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 33,
        "title": "Implement difficulty-config.schema.json with versioning and lock constraints",
        "description": "Create JSON schema for difficulty configuration, including version field, difficulty levels, and constants, ensuring difficulty is locked at run start per PRD.",
        "details": "Create difficulty-config.schema.json in config/schemas/. Define schema with properties: version (string, required), difficulty_level (string enum: [\"easy\", \"medium\", \"hard\"]), modifiers (object with numeric fields). Include explicit version field for backward-trackability. Enforce that all values are configurable. Pseudo-code: { \"version\": { \"type\": \"string\", \"pattern\": \"^\\\\d+\\\\.\\\\d+$\" }, \"difficulty_level\": { \"type\": \"string\", \"enum\": [\"easy\", \"medium\", \"hard\"] } }.",
        "testStrategy": "Test schema validation with sample files, check that invalid enums or missing version are rejected. Verify version field is present and follows pattern.",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define difficulty schema and lock rules",
            "description": "Define difficulty tiers, locked-session constraints, and version metadata requirements.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock schema fields for level definitions, lock policy, and migration metadata.",
            "testStrategy": "Schema tests verify required tier fields and lock constraints.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement difficulty schema validation",
            "description": "Implement parser/validator for tier values, bounds, and compatibility rules.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply strict validation with clear reject reasons for invalid tiers.",
            "testStrategy": "Validation tests verify bounds, missing fields, and type mismatch handling.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add difficulty schema regression samples",
            "description": "Add canonical samples and negative fixtures for schema drift prevention.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit schema validation evidence and fallback behavior for invalid configs.",
            "testStrategy": "Regression tests verify stable validation against sample fixtures.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 34,
        "title": "Implement spawn-config.schema.json for deterministic wave composition",
        "description": "Define JSON schema for spawn configuration to control enemy waves, ensuring determinism: same seed + same config => same wave timeline.",
        "details": "Create spawn-config.schema.json in config/schemas/. Include properties: seed (integer), waves (array of wave objects with day/night timing, enemy counts). Align with match duration (60-90 mins) and day/night cycle (4 min Day + 2 min Night, Day1-Day15). Use config values only. Pseudo-code: { \"seed\": { \"type\": \"integer\" }, \"waves\": [ { \"day\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 15 }, \"enemies\": [ { \"enemy_id\": \"string\", \"count\": { \"type\": \"integer\", \"minimum\": 0 } } ] } ] }.",
        "testStrategy": "Validate schema with test data, ensure it enforces day range 1-15 and non-negative counts. Test determinism by generating waves with fixed seed and config.",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": [],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 35,
        "title": "Implement pressure-normalization.config.schema.json with baseline constants and range checks",
        "description": "Create JSON schema for pressure normalization configuration, including explicit baseline constants and validation for ranges as per PRD.",
        "details": "Create pressure-normalization.config.schema.json in config/schemas/. Define properties: baseline (number), min_pressure (number), max_pressure (number), normalization_factors (array of numbers). Include range checks (e.g., min < max). Use explicit constants. Pseudo-code: { \"baseline\": { \"type\": \"number\", \"minimum\": 0 }, \"min_pressure\": { \"type\": \"number\" }, \"max_pressure\": { \"type\": \"number\" }, \"constraints\": { \"type\": \"object\", \"properties\": { \"range_check\": { \"type\": \"boolean\" } } } }.",
        "testStrategy": "Test schema validation to ensure it rejects invalid ranges (e.g., min_pressure > max_pressure). Verify baseline is a number.",
        "priority": "medium",
        "dependencies": [
          31
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define pressure-normalization schema constraints",
            "description": "Define baseline constants, range checks, and normalization fields for pressure control.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock schema fields that normalize pressure inputs and cap unsafe values.",
            "testStrategy": "Schema tests verify baseline constants and allowed range declarations.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement normalization schema validation flow",
            "description": "Implement validation and typed mapping for normalization config values.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply strict reject/fallback behavior when normalization values are out of range.",
            "testStrategy": "Validation tests verify deterministic parsing and range enforcement.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add normalization regression and baseline fixtures",
            "description": "Add sample fixtures and negative cases to prevent drift in normalization behavior.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit normalization validation evidence and fallback reason codes.",
            "testStrategy": "Regression tests verify stable baseline behavior across config revisions.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 36,
        "title": "Create sample JSON files for all configs with valid data",
        "description": "Generate sample JSON files (difficulty-config.sample.json, spawn-config.sample.json, pressure-normalization.config.sample.json) that adhere to the schemas and include realistic values.",
        "details": "Treat sample generation as a contract release artifact, not a static placeholder. Split by config domain and require positive+negative validation fixtures before acceptance.",
        "testStrategy": "Validate each sample with schema and semantic validator rules, then run negative fixtures to ensure reject paths are effective.",
        "priority": "medium",
        "dependencies": [
          32,
          33,
          34,
          35
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Generate difficulty sample aligned with schema caps",
            "description": "Create difficulty sample values consistent with lock-at-start and bounded percentage fields.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "32"
            ],
            "details": "Emit a clean sample with version metadata and deterministic defaults for launch tiers.",
            "testStrategy": "Schema validation passes and lock-at-start fields are present.",
            "subtasks": []
          },
          {
            "id": 2,
            "title": "Generate spawn sample with channel and cadence coverage",
            "description": "Create spawn sample covering normal/elite/boss channels, lane settings, and timing cadence.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "33"
            ],
            "details": "Include Day1-Day15 coverage and channel isolation flags needed by runtime parser.",
            "testStrategy": "Schema + validator rules pass for required cadence and channel constraints.",
            "subtasks": []
          },
          {
            "id": 3,
            "title": "Generate pressure-normalization baseline sample",
            "description": "Create normalization sample with baseline constants and range-safe tuning values.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "34"
            ],
            "details": "Ensure baseline constants are explicit and tuning values remain within guard bands.",
            "testStrategy": "Validation confirms constants and range checks are enforced.",
            "subtasks": []
          },
          {
            "id": 4,
            "title": "Add negative fixtures and validation summary artifact",
            "description": "Provide invalid fixtures and expected rejection reasons for contract hardening.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "36.1",
              "36.2",
              "36.3",
              "35"
            ],
            "details": "Create malformed and boundary-breach samples; export validation summary for CI review.",
            "testStrategy": "Negative cases fail with explicit reason codes; positive samples remain green.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 37,
        "title": "Implement config validation and fallback handling in C#",
        "description": "Develop C# code in Godot to load and validate config files against schemas, applying invalid config handling policy: reject and fallback to built-in safe defaults.",
        "details": "Implement config validation/fallback as layered policy: structural validation, semantic validation, policy routing, runtime integration, and audit output. Ensure rejection reasons are explicit and testable.",
        "testStrategy": "Validate success/failure matrix across valid, invalid, and boundary config inputs; confirm fallback or reject behavior matches policy and logs are emitted.",
        "priority": "medium",
        "dependencies": [
          32,
          33,
          34,
          35
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement schema-level structural validation adapters",
            "description": "Bind JSON schema checks for all core config files before runtime consumption.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "31",
              "32",
              "33",
              "34"
            ],
            "details": "Centralize structural validation and collect normalized error payloads.",
            "testStrategy": "Structural invalid payloads fail with deterministic error codes.",
            "subtasks": []
          },
          {
            "id": 2,
            "title": "Implement semantic rule validation and policy router",
            "description": "Apply cross-field semantics and route outcomes to reject/fallback branches.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "37.1",
              "35"
            ],
            "details": "Encode rule sets from validator contracts and map each failure to policy action.",
            "testStrategy": "Rule-violation cases trigger expected policy outcomes and reason keys.",
            "subtasks": []
          },
          {
            "id": 3,
            "title": "Integrate runtime fallback application boundaries",
            "description": "Apply safe defaults only for allowed cases and block forbidden runtime overrides.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "37.2",
              "36"
            ],
            "details": "Enforce difficulty lock and immutable runtime fields while applying allowed fallbacks.",
            "testStrategy": "Integration tests confirm allowed fallbacks apply, forbidden cases reject.",
            "subtasks": []
          },
          {
            "id": 4,
            "title": "Emit validation audit and incident artifacts",
            "description": "Persist validation outcomes with reason, target, and caller for traceability.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "37.3"
            ],
            "details": "Write standardized audit entries and summary outputs to logs/ci paths.",
            "testStrategy": "Audit tests verify required fields and policy decision trace completeness.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 38,
        "title": "Integrate config governance for gameplay tuning",
        "description": "Connect config values to gameplay systems (e.g., enemy stats, wave spawning) to ensure all tuning is via config only, with no implementation hardcoding.",
        "details": "Modify existing gameplay C# scripts to read values from ConfigManager instead of hardcoded constants. For example, enemy health from enemy-config, wave timing from spawn-config. Ensure determinism by using seed from spawn-config for random generation. Pseudo-code: Enemy.health = ConfigManager.GetEnemyConfig(enemyId).health; WaveSpawner.seed = ConfigManager.GetSpawnConfig().seed;.",
        "testStrategy": "Integration tests: run gameplay with different configs, verify enemy stats and wave compositions change accordingly. Check that no hardcoded values override configs.",
        "priority": "medium",
        "dependencies": [
          37
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define config-governance policy contract",
            "description": "Define governance checks for schema completeness, ownership, and promotion flow.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock mandatory governance fields and promotion preconditions for tuning configs.",
            "testStrategy": "Contract tests verify governance metadata and promotion prerequisites.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement governance checks in tuning workflow",
            "description": "Implement validation gates that enforce governance policy before runtime config adoption.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply fail-fast governance checks and deterministic reject reasons.",
            "testStrategy": "Workflow tests verify blocked promotion on missing governance criteria.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add governance regression and audit outputs",
            "description": "Cover policy bypass attempts, partial updates, and audit trace completeness.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit governance audit artifacts for CI/manual review handoff.",
            "testStrategy": "Regression tests verify governance checks remain enforced after updates.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 39,
        "title": "Add config hash/version to battle report metadata for auditability",
        "description": "Implement functionality to compute and include config hash or version in battle report metadata, as required for auditability.",
        "details": "In ConfigManager, add method to compute hash (e.g., SHA256) of config files or extract version fields. Store this in a BattleReport class along with match results. Ensure it's included when generating reports. Pseudo-code: string configHash = ComputeHash(configJson); battleReport.Metadata.Add(\"config_hash\", configHash);.",
        "testStrategy": "Test that battle report includes config hash/version metadata. Verify hash changes when config changes, and is consistent for same config.",
        "priority": "low",
        "dependencies": [
          37
        ],
        "status": "pending",
        "subtasks": [],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      },
      {
        "id": 40,
        "title": "Implement version migration rule with force migration",
        "description": "Develop version handling to force migration when config version changes, without dual-version compatibility, per PRD.",
        "details": "In ConfigManager, check version field of loaded config against expected version. If mismatch, reject config and force fallback to default, logging migration requirement. Do not support multiple versions. Pseudo-code: if (config.version != expectedVersion) { Log.Error(\"Version mismatch, migration required\"); return LoadDefault(); }.",
        "testStrategy": "Unit tests: provide configs with different versions, ensure they are rejected and fallback occurs. Verify no compatibility mode is active.",
        "priority": "medium",
        "dependencies": [
          37
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "Define forced-migration rule contract",
            "description": "Define migration trigger conditions, version boundaries, and failure behavior contract.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [],
            "details": "Lock forced migration policy and reject-load behavior on unrecoverable migration failure.",
            "testStrategy": "Contract tests verify migration trigger matrix and failure policy.",
            "subtasks": []
          },
          {
            "id": "2",
            "title": "Implement version migration executor",
            "description": "Implement migration steps, state transformation, and deterministic version bump handling.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "1"
            ],
            "details": "Apply deterministic migration sequence with strict validation per step.",
            "testStrategy": "Unit tests verify migration correctness across supported version paths.",
            "subtasks": []
          },
          {
            "id": "3",
            "title": "Add migration regression and failure-path tests",
            "description": "Cover broken payloads, unsupported versions, and forced-fail user guidance outputs.",
            "status": "pending",
            "priority": "medium",
            "dependencies": [
              "2"
            ],
            "details": "Emit migration diagnostics and enforce reject-load on fatal migration failures.",
            "testStrategy": "Regression tests verify deterministic migration and rejection behavior.",
            "subtasks": []
          }
        ],
        "overlay": "docs/architecture/overlays/PRD-lastking-T2/08/_index.md"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-11T20:30:07",
      "taskCount": 40,
      "completedCount": 0,
      "tags": [
        "master"
      ],
      "migration": "legacy-master-to-standard-repair",
      "created": "2026-02-19T14:29:31.954Z",
      "description": "Tasks for master context"
    }
  }
}
